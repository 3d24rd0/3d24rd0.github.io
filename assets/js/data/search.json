[ { "title": "QUBES OS Primeros pasos", "url": "/posts/qubes_os_primeros_pasos/", "categories": "Blog, やみのきし", "tags": "Guía, linux, Qubes OS", "date": "2016-06-07 01:55:21 +0200", "snippet": "QUBES OS se centra en la seguridad del sistema e implementa seguridad por aproximación de Aislamiento.La versión con la que comencé a probarla fue la “3RC2”, para mi sorpresa, anaconda el Instalador de la distribución, se me quedaba colgado nada mas iniciarse. El problema, aparentemente se debía a la gráfica “ATI”.Al basarse este sistema en múltiples máquinas virtuales, las primeras preguntas con los que me encontré fueron:* ¿Cómo usar el portapapeles?* ¿Cómo copiar ficheros?Uso del portapapelesPara comprender el uso de el portapapeles de Qubes, tenemos que pensar que existen 2, uno propio de cada maquina virtual, el cual podremos usar con normalidad como siempre; Y un segundo “genérico” entre todas las maquinas. Para copiar o pegar algo entre maquinas tendremos que, primero copiar lo que queramos de la maquina en cuestión (ctrl-c), y segundo, (ctrl-alt-c) copiándose así el portapapeles de la maquina virtual al portapapeles genérico, como podremos imaginarnos para pegar (ctrl-alt-v) y (ctrl-v) en la maquina que queramos.Copiar ficherosQubes nos permite copiar ficheros entre los distintos dominios mediante el uso del comando :qvm-copy-to-vm [–without-progress] dest_vmname file [file]Como se puede ver en el comando, se especifica el dominio de destino y qué fichero copiar.¿Pero donde lo copia?En la “home” del dominio tendremos una carpeta “QubesIncoming” y dentro de ella el nombre de la maquina origen, y en su interior se encuentran los ficheros que se mandaron a copiar.Maquinas desechablesQUBES OS nos da la posibilidad de usar maquinas para un solo uso, con esto me refiero a que podemos realizar cualquier acción, y cuando se termine, se apagará, y se borrará la maquina con todos los datos usados, donde hemos podido usar datos sensibles.Esto es útil si queremos realizar alguna acción en la que tengamos dudas de su fiabilidad, como por ejemplo, abrir una web de origen sospechoso.Desde cualquier Dominio, si tenemos las “Tools” de QUBES OS, podremos abrir cualquier fichero de forma gráfica:Y desde “commandline”:qvm-open-in-dvm fileTambién tenemos un acceso directo creado en el menú del sistema para abrir fácilmente un navegador.La plantilla utilizada por defecto sería “fedora-23-dvm”. Si queremos cambiar de plantilla, podremos utilizar el siguiente comando:qvm-create-default-dvm &amp;lt;custom-template-name&amp;gt;Actualizar QUBES OSDesde la herramienta “Qubes VM Manager” tendremos la opción de actualizar de una forma sencilla, cuando las actualizaciones sean detectadas, sin embargo, si queremos forzar la actualización de algún “template” podremos encenderla y actualizarla (en caso de usar windows tendrá que ser así).Para actualizar el dom0 podremos mediante el comando:qubes-dom0-updatequbes-dom0-update --enablerepo=qubes*testingHabilitar pantalla completaPor defecto Qubes OS no permite el uso de pantalla completa, porque es considerado un fallo de seguridad, ya que, un atacante podría aprovechar esa funcionalidad para simular nuestro sistema, cambiarnos nuestro entorno y terminar escribiendo alguna “password” donde realmente no deberíamos.Si aún así, queremos, por ejemplo, ver vídeos a pantalla completa, tendremos que modificar el fichero /etc/qubes/guid.conf.Para especificar una maquina en concreto, la sintaxis sería la siguiente:VM: { Dominio: { allow_fullscreen = true; };};También tendremos la posibilidad de activarlo de forma global:global: { allow_fullscreen = true; };Y si fuese el caso del ejemplo (el de reproducir un vídeo), puede que también nos interese activar la opción “audio_low_latency**” **a false pasando a un retardo máximo a 40ms, comparado a 200-500ms, que hay por defecto. Hay que tener en cuenta que esto aumentara el uso de CPU.Instalación de windows 7 como plantilla en QUBES OSQubes OS permite a las máquinas HVM compartir un sistema de archivos raíz común de un Template, al igual que se hace para Linux AppVMs. Éste modo no se limita a Windows AppVMs, y se puede utilizar para cualquier HVM (por ejemplo, FreeBSD).qvm-create --hvm-template -l black windows-7[Por defecto se crean dos discos para maquinas HVM:1. La raíz del sistema (20GB)2. Uno pirvado para la home (2GB)Ahora iniciaremos la maquina virtual con la iso/cd con el que realizaremos la instalación:qvm-start windows-7 --cdrom=/usr/local/iso/win7_en.iso--cdrom=/dev/cdrom--cdrom=[appvm]:[/path/to/iso/within/appvm]Una vez instalado Windows, tendremos que instalar las “Tools” de Qubes OS. Viene pre-seleccionada la opción para almacenar el directorio “C:\\Users” en el segundo disco, que crea automáticamente Qubes OS (el privado). Éste segundo disco no se restablece al reiniciar, así que los directorios y perfiles del usuario sobrevivirían tras cada reinicio, a diferencia del sistema de archivos “raíz”, que se restablece a la imagen del Template automáticamente.Si se selecciona esta característica la instalación requerirá de dos reinicios:1. Se inicializará y se dará formato al disco privado en el primer reinicio (no se puede hacer durante la instalación, debido a que los controladores de almacenamiento masivo Xen aún no están activos).2. Los perfiles de usuario se mueven en el disco privado.Ésto se realizará automáticamente con el instalador, por lo que, simplemente deberemos dejar que él solo termine.Instalación de QUBES OS ToolsInstalar/Actualizar las herramientas para Windows en Qubes OS:qubes-dom0-update --enablerepo=qubes*testing qubes-windows-toolsPara poder ejecutar Qubes Tools, tendremos que deshabilitar el chequeo de drivers firmados, para ello tendremos que ejecutar la terminal como administrador, lanzar el siguiente comando y reiniciar:bcdedit /set testsigning onTeniendo la maquina apagada, podremos iniciar la instalación de las Tools mediante el siguiente comando:qvm-start win7-x64-template --install-windows-toolsOptimizaciónEn la web oficial de Qubes OS existe documentación para la optimización de Windows link, que seria interesante realizar.Aumentar TimeOutPodemos aumentar el “timeout” por defecto de Qubes OS, ya que esto puede venir bien para Windows, puesto que puede ser mas lento (por defecto 60s):qvm-prefs -s &amp;lt;vm-name&amp;gt; qrexec-timeout 300Creación de dominiosUna vez que la plantilla se ha creado, es muy fácil crear Dominios basados en ella.Ejecutando el siguiente comando:qvm-create --hvm &amp;lt;new windows appvm name&amp;gt; --template &amp;lt;name of template vm&amp;gt; --label &amp;lt;label color&amp;gt;Hay que tener en cuenta, que la raíz se copiará de la plantilla en cada inicio,(recordar que podemos tener la unidad “D” con la home del usuario). En caso de querer guardar cosas en el disco principal y no perderlos al reiniciar, ya sea porque lo requiera alguna aplicación o cualquier motivo de desarrollo, podemos aprovechar igualmente la plantilla y crear dominios con la opción “Standalone” (no modificará la raíz en cada inicio), solamente tendremos que añadir la opción “–standalone” al comando anterior.Ejecutar aplicacionesPara lanzar aplicaciones desde dom0:qvm-run -a MyWIn7 explorer.exePara lanzarlas desde otro dominio:qvm-open-in-vm MyWin7 http://yaminokishi.com" }, { "title": "My Pinned Site", "url": "/posts/my-pinned-site/", "categories": "Blog, やみのきし", "tags": "Guía, pinned, web, windows", "date": "2016-02-23 01:10:11 +0100", "snippet": "A partir de IE11  podemos crear iconos personalizados para sitios web creando “browserconfig.xml” en la raíz del sitio, que posteriormente también es utilizado por windows 8.1 para anclar la web en la interfaz metro.En este XML podemos especificar el icono en los distintos tamaños en los que queramos que pueda ser visto y el color de fondo, lo que vendría siendo :&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;browserconfig&amp;gt; &amp;lt;msapplication&amp;gt; &amp;lt;tile&amp;gt; &amp;lt;square70x70logo src=&quot;images/smalltile.png&quot;/&amp;gt; &amp;lt;square150x150logo src=&quot;images/mediumtile.png&quot;/&amp;gt; &amp;lt;wide310x150logo src=&quot;images/widetile.png&quot;/&amp;gt; &amp;lt;square310x310logo src=&quot;images/largetile.png&quot;/&amp;gt; &amp;lt;TileColor&amp;gt;#009900&amp;lt;/TileColor&amp;gt; &amp;lt;/tile&amp;gt; &amp;lt;/msapplication&amp;gt;&amp;lt;/browserconfig&amp;gt;Es necesario añadir en la cabecera del HTML las siguientes líneas :&amp;lt;meta name=&quot;application-name&quot; content=&quot;YAMI NO KISHI&quot;/&amp;gt;&amp;lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#303030&quot;/&amp;gt;&amp;lt;meta name=&quot;msapplication-config&quot; content=&quot;browserconfig.xml&quot; /&amp;gt;El resultado final, para que nos situemos de lo que hablamos, sería:También da la opción de añadir notificaciones, quedando el XML de la siguiente estructura:&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;browserconfig&amp;gt; &amp;lt;msapplication&amp;gt; &amp;lt;tile&amp;gt; &amp;lt;square70x70logo src=&quot;images/smalltile.png&quot;/&amp;gt; &amp;lt;square150x150logo src=&quot;images/mediumtile.png&quot;/&amp;gt; &amp;lt;wide310x150logo src=&quot;images/widetile.png&quot;/&amp;gt; &amp;lt;square310x310logo src=&quot;images/largetile.png&quot;/&amp;gt; &amp;lt;TileColor&amp;gt;#009900&amp;lt;/TileColor&amp;gt; &amp;lt;/tile&amp;gt; &amp;lt;notification&amp;gt; &amp;lt;polling-uri src=&quot;notifications/contoso1.xml&quot;/&amp;gt; &amp;lt;polling-uri2 src=&quot;notifications/contoso2.xml&quot;/&amp;gt; &amp;lt;polling-uri3 src=&quot;notifications/contoso3.xml&quot;/&amp;gt; &amp;lt;frequency&amp;gt;30&amp;lt;/frequency&amp;gt; &amp;lt;cycle&amp;gt;1&amp;lt;/cycle&amp;gt; &amp;lt;/notification&amp;gt; &amp;lt;/msapplication&amp;gt;&amp;lt;/browserconfig&amp;gt;Con “cycle” se puede controlar cómo se realiza el ciclo de los mensajes: 0: (predeterminado si es solamente una notificación) no realizar ciclo. 1: (predeterminado si son varias notificaciones) realizar ciclo de notificaciones para todos los tamaños de icono. 2: solamente realizar ciclo de notificaciones para iconos medianos. 3: solamente realizar ciclo de notificaciones para iconos anchos. 4: solamente realizar ciclo de notificaciones para iconos grandes. 5: solamente realizar ciclo de notificaciones para iconos medianos o anchos. 6: solamente realizar ciclo de notificaciones para iconos medianos o grandes. 7: solamente realizar ciclo de notificaciones para iconos anchos o grandes.Con la opción “frequency” se especifica (en minutos) el intervalo de sondeo, debe ser una de las siguientes: 30, 60, 360, 720 o 1440. y parece ser que podemos añadir hasta 5 “polling-uriX” y se mostrarían de forma aleatoria.La estructura básica del XML al que apunta en “polling-uriX” sería la siguiente:&amp;lt;tile&amp;gt;&amp;lt;visual lang=&quot;en-US&quot; version=&quot;2&quot;&amp;gt; &amp;lt;binding template=&quot;TileSquare150x150PeekImageAndText04&quot; branding=&quot;name&quot;&amp;gt;&amp;lt;image id=&quot;1&quot; src=&quot;images/2.jpg&quot;/&amp;gt;&amp;lt;text id=&quot;1&quot;&amp;gt;Serving Today: Samosas&amp;lt;/text&amp;gt; &amp;lt;/binding&amp;gt;&amp;lt;binding template=&quot;TileWide310x150ImageAndText01&quot; branding=&quot;name&quot;&amp;gt;&amp;lt;image id=&quot;1&quot; src=&quot;images/2.jpg&quot;/&amp;gt; &amp;lt;text id=&quot;1&quot;&amp;gt;Serving Today: Samosas&amp;lt;/text&amp;gt;&amp;lt;/binding&amp;gt;&amp;lt;binding template=&quot;TileSquare310x310ImageAndText01&quot; branding=&quot;name&quot;&amp;gt;&amp;lt;image id=&quot;1&quot; src=&quot;images/2jpg&quot;/&amp;gt;&amp;lt;text id=&quot;1&quot;&amp;gt;Serving Today: Samosas&amp;lt;/text&amp;gt;&amp;lt;/binding&amp;gt;&amp;lt;/visual&amp;gt;&amp;lt;/tile&amp;gt;Si nos fijamos nos encontramos una raíz “binding” por resolución.Para quien le interese el tema, y quiera añadirlo en una web, existe una herramienta online en la que nos ayudará a crear el XML buildmypinnedsite. Ésta web nos facilitará crear las notificaciones a partir de un RSS generando el XML anteriormente descrito a partir de un “api” “http://notifications.buildmypinnedsite.com/?feed={URL_RSS};id=1”, id por notificación.Viéndose las notificaciones de la siguiente manera:Y para todo aquel que aún no sepa cómo anclar una web aquí un video que lo explica." }, { "title": "IncludeOS el unikernel de c++", "url": "/posts/includeos-el-unikernel-de-cpp/", "categories": "Blog, やみのきし", "tags": "cpp, IncludeOS, Programación", "date": "2015-12-21 01:27:18 +0100", "snippet": "IncludeOS es un unikernel escrito desde cero, utilizando la virtualización de hardware x86, sin dependencias, excepto para el hardware virtual, actualmente es un prototipo.Características* IncludeOS pretende ser la capa más pequeña posible entre el código C++ y el hardware virtual.* Con IncludeOS podremos crear **un servicio en la nube escrito en C++** que contendrá unicamente las librerías necesarias para ejecutarse.* El resultado de la compilación nos dará como resultado una **imagen de disco**, que contendrá la aplicación y los pocos componentes necesarios de un S.O para ser ejecutado.* Ésta imagen se podrá ejecutar en **KVM** y en VirtualBox.* La imagen que es generada, ocupará al rededor de unos** 693k.*** El modelo de programación con IncludeOS está inspirado en **Node.js**, utiliza **un solo hilo** y devuelve **callbacks asíncronos**.Podremos ver todas sus características y limitaciones en el siguiente link.Sin duda, la elección de este tipo diseño y lenguaje, ofrecerá grandes ventajas para la creación de servicios web, con una eficiencia mayor a la que estamos acostumbrados a ver en servicios escritos en lenguajes de alto nivel, como puedan ser Java, JS o C#,El “Hello World”Bueno, ahora los mas importante: ¿Cómo diablos hacemos para crear nuestro primer Hello world?.Nos descargaremos desde el repositorio oficial el proyecto. En él encontraremos un script que nos instalará las dependencias y realizará las configuraciones necesarias.Éste script está preparado para sistemas basados en Debian.git clone https://github.com/h1ioa-cs/IncludeOS.gitcd IncludeOS./etc/install_from_bundle.shConfiguraciónEn caso de querer modificar la IP o puerto al que responde el servicio podemos modificarlo desde el fichero:IncludeOS/examples/demo_service/service.cpp // Static IP configuration, until we (possibly) get DHCP // @note : Mostly to get a robust demo service that it works with and without DHCP inet-&amp;gt;network_config( 192, // IP 255, // Netmask 192, // Gateway 8 ); // DNS printf(&quot;Size of IP-stack: %i b \\n&quot;,sizeof(inet)); printf(&quot;Service IP address: %s \\n&quot;, inet-&amp;gt;ip_addr().str().c_str()); // Set up a TCP server on port 80 net::TCP::Socket&amp;amp; sock = inet-&amp;gt;tcp().bind(80);También podemos modificar el bridge que crea por defecto al ejecutar “install_from_bundle.sh” desde el fichero “IncludeOS/etc/create_bridge.sh”BRIDGE=include1NETMASK=255.255.255.0GATEWAY=192.168.1.1# For later useNETWORK=192.168.1.0DHCPRANGE=192.168.1.50,192.168.1.60EjecuciónAntes de ejecutar  “test.sh” nos fijamos que “install_from_bundle.sh” no devolvió ningún error../test.shUna vez termine la ejecución del script, nos encontraremos con la siguiente salida, que nos muestra la ip donde tendremos el servicio corriendo, por defecto “Service IP address: 10.0.0.42”Resultado" }, { "title": "Actualizar a Fedora 23 con DNF", "url": "/posts/actualizar-a-fedora-23-con-dnf/", "categories": "Blog, やみのきし", "tags": "Guía, Linux, Fedora", "date": "2015-11-07 01:25:10 +0100", "snippet": "Es posible que estemos acostumbrados a actualizar nuestro Fedora mediante Fedup, pero desde la versión 23, incluye un nuevo método de actualización, utilizando algunas de las ventajas proporcionadas por el nuevo gestor de paquetes DNF, que podremos aprovechar desde la versión 21.Lo primero que tendremos que hacer es actualizar el sistema:sudo dnf updateInstalamos el plugin de DNF “el que realizará la magia”: sudo dnf install dnf-plugin-system-upgradeA continuación, descargaremos todas las actualizaciones necesarias para actualizar a la versión 23:sudo dnf system-upgrade download --releasever=23 --bestCon el parámetro –best evitará actualizar paquetes que puedan dar errores por dependencias.Una vez que ya tenemos todo lo necesario para actualizar, reiniciaremos en “modo upgrade”:sudo dnf system-upgrade rebootDurante este arranque, Fedora se actualizará de versión y tendremos nuestro sistema actualizado.Podemos verificar, que se actualizó correctamente mediante el comando :cat /etc/redhat-releaseAhora es recomendable reconstruir la base de datos y sincronizar:sudo rpm --rebuilddbsudo dnf distro-sync --setopt=deltarpm=0" }, { "title": "Post-Instalación openSUSE", "url": "/posts/post-instalacion-opensuse/", "categories": "Blog, やみのきし", "tags": "Linux, Suse, Guía", "date": "2015-11-02 21:27:41 +0100", "snippet": "En esta guía utilizaré ha menudo “Alt+F2”, con ello me refiero a lanzar el  “ejecutador de órdenes”:También nos servirá cualquier otro buscador/ejecutador que utilizamos como el que incorpora actualmente openSUSE en el “Menú de aplicaciones”.Desactivar el bloqueo de pantallaAccederemos mediante (Alt+F2)–&amp;gt;”Bloqueo de pantalla” y desactivamos la opción de bloquear la pantalla automáticamente.Deshabilitar la restauración de sesiónPodemos mejorar el tiempo de inicio evitando que se lancen las aplicaciones que teníamos abiertas en la sesión anterior,  iniciando por defecto con una sesión vacía (por defecto se guarda).Accederemos mediante (Alt+F2)–&amp;gt;”Preferencias del sistema”–&amp;gt;”Arranque y apagado” y seleccionamos la pestaña de “Sesión de escritorio” o también podemos ir directamente mediante (Alt+F2)–&amp;gt;”Sesión de escritorio”.Una vez en el panel en la sección “Al iniciar sesión” y seleccionamos “Comenzar con una sesión vacía”.Idioma predefinidoPara seleccionar el idioma predefinido que queramos (Alt+F2)–&amp;gt;”Traducciones” y pasamos el idioma que deseemos desde la fila de idiomas disponibles a idiomas predefinidos en el orden deseado. zypper in bundle-lang-commom-es bundle-lang-kde-es kde-l10n-es kde-l10n-es kde-l10n-es-doc kde-l10n-es-data yast2-trans-es translation-update-esEn caso de que usemos Libreoffice:zypper in libreoffice-l10n-esEn caso de que usemos Calligra:zypper in calligra-l10n-es calligra-l10n-es-docDeshabilitar el compositor en pantalla completa(Alt+F2)–&amp;gt;”Compositor” y seleccionamos “Suspender el compositor en las ventanas a pantalla completa” , en caso de necesitar drivers gráficos de terceros, este paso deberemos realizarlo después de su instalación.Deshabilitar repositorio de instalaciónDesde (Alt+F2)–&amp;gt;Yast–&amp;gt;”Repositorios de software” o (Alt+F2)–&amp;gt;”Repositorios de software” y seleccionamos el repositorio que se añadió automáticamente durante la instalación del DVD o USB  y lo podremos deshabilitar o borrar directamente.Configurar la red mediante NetworkManager(Alt+F2)–&amp;gt;Yast–&amp;gt;”Ajustes de red” o (Alt+F2)–&amp;gt;”Ajustes de red”, seleccionamos la pestaña de “opciones globales” en “Network Setup Method” y seleccionaremos “NetworkManager Service”.Desde aquí también podremos deshabilitar IPv6 (en caso de que no lo vallamos a utilizar) y desde la pestaña de Hostname/DNS, podremos especificar nuestro Hostname y Domain Name.Servicios(Alt+F2)–&amp;gt;Yast–&amp;gt;”Administrador de servicio” y deshabilitamos los servicios que no utilizamos como pueda ser Bluetooth.Optimizar SSD1- Actualizar FirmwareLo primero que tendríamos que realizar con nuestro SSD es actualizar su firmware, en la wiki de arch tenemos una bonita sección donde podremos encontrar información de los principales fabricantes.2- Optimizar el sistemaEn los siguientes enlaces, podremos encontrar de forma general los pasos que deberíamos realizar en nuestro SUSE:* https://en.opensuse.org/SDB:SSD_performance* https://lizards.opensuse.org/2015/02/06/ssd-configuration-for-opensuse/A partir de la información sacada en los enlaces anteriores, realicé las siguientes modificaciones:2.1- Trimsystemctl enable fstrim.timersystemctl start fstrim.timer2.2- Tuning the kernelEditaremos o crearemos el fichero /etc/udev/rules.d/60-sched.rulesnano /etc/udev/rules.d/60-sched.rules#set noopscheduler for non-rotating disks ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR{queue/rotational}==&quot;0&quot;, ATTR{queue/scheduler}=&quot;deadline&quot;# set cfqscheduler for rotating disks #ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR{queue/rotational}==&quot;1&quot;, ATTR{queue/scheduler}=&quot;cfq&quot; #### 2.3- Readaheadsystemctl disable systemd-readahead-collect.servicesystemctl disable systemd-readahead-replay.service2.4- SwapEditaremos o crearemos el fichero /etc/sysctl.d/99-sysctl.confsudo vi /etc/sysctl.d/99-sysctl.confvm.swappiness=1vm.vfs_cache_pressure=50CodecsInstalaremos los codecs mediante 1-click de opensuse-community.Otros codecs necesarios que deberemos instalar manualmente:zypper in gstreamer-0_10-plugins-ugly libdvdcss2 vlc libxine2-codecs libxine2-pulse k3b-codecs lame gstreamer-0_10-plugins-ffmpeg gstreamer-0_10-plugins-bad gstreamer-0_10-plugins-ugly gstreamer-0_10-plugins-ugly-orig-addon w32codec-all MPlayer smplayer smplayer-lang gstreamer-0_10-plugins-good libxine2 libdvdplay0 libdvdread4 libdvdnav4 libmad0 libavutil51 sox libxvidcore4 xvidcore libavcodec52 libavdevice52 libvlc5 lsb pullin-flash-player flash-player gstreamer-0_10-fluendo-mp3 gstreamer-0_10-plugins-fluendo_mpegdemux gstreamer-0_10-plugins-fluendo_mpegmux gstreamer-0_10-plugins-base gstreamer-0_10-plugins-good-extra k3b vlc-codecs vlc-aout-pulse libquicktime0 gstreamer-0_10-plugins-bad-orig-addon xine-browser-pluginzypper dup --from Packman Repository #en caso de tener problemas confirmar nombre del repositorioActualizar el Sistemazypper ref #Actualizamos los repositorioszypper up #Actualizamos el softwarezypper dup #Actualizamos el systemazypper inr #Instalamos paquetes recomendados por SUSEInstalación de softwareMi recomendación a la hora de instalar cualquier cosa en SUSE, sería seguir el siguiente orden a la hora de buscar un paquete para su instalación:1. Buscarlo en los repositorios que ya estemos usando &quot;zypper ref &amp;amp;&amp;amp; zypper se (software que busquemos)&quot;.2. Buscarlo en [1-Click ](https://software.opensuse.org/search?utf8=%E2%9C%93&amp;amp;q=&amp;amp;search_devel=false&amp;amp;search_unsupported=false&amp;amp;baseproject=openSUSE%3A13.2)3. Buscar un RPM desde la web del software, (en caso de no existir paquete para SUSE nos podría valer el de Fedora)4. Podríamos usar un paquete de otra distribución y mediante [alien](https://www.google.es/search?num=20&amp;amp;newwindow=1&amp;amp;safe=off&amp;amp;q=alien+deb+to+rpm&amp;amp;spell=1&amp;amp;sa=X&amp;amp;ved=0CBsQvwUoAGoVChMI5NyU2sTyyAIVx_I-Ch3AQQRy&amp;amp;biw=1861&amp;amp;bih=980) traducirlo a RPM.Hay que tener cuidado con los repositorios externos que se suelen añadir automáticamente en la instalación, y según el software, no guardar el repositorio, o bajarle la prioridad, para evitar conflictos con los repositorios oficiales, o entre repositorios externos, normalmente esto dependerá de lo cuan actualizado queramos tener ese software.A continuación dejare algunos ejemplos de software que normalmente instalo, en recomendación de @aldobelus quisiera destacar que muchos de ellos son software privativo y que normalmente son con los que mayoritariamente podamos tener problemas en nuestro SUSE.Ejemplos:Hangoutwget https://dl.google.com/linux/direct/google-talkplugin_current_x86_64.rpmzypper in ./google-talkplugin_current_x86_64.rpmDropboxMediante 1-click desde openSUSE podremos instalarlo.Chromewget https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpmzypper in ./google-chrome-stable_current_x86_64.rpmOperazypper in operaQupzillazypper in qupzillaSlackDescargamos el RPM desde https://slack.com/apps (el de Fedora nos valdrá).zypper in ./slack-1.2.4-0.1.fc21.x86_64.rpmSkypeMediante 1-click desde SUSE podremos instalarlo." }, { "title": "EmulationStation con DietPi", "url": "/posts/emulationstation-con-dietpi/", "categories": "Blog, やみのきし", "tags": "Blog, Raspberry pi, Guía", "date": "2015-10-24 21:20:52 +0200", "snippet": "Selección de distribuciónPersonalmente pienso que Raspbian trae más paquetes pre-instalados de los que necesito, por lo que me decanto más por una distribución más reducida, debido a que el script de instalación está optimizado para Raspbian, utilizaré alguna basada en ésta.En este link podremos encontrar una comparativa entre DietPi y Minibian. Me decanto por DietPi, por lo que la instalación sera en base a ella, aunque utilizar cualquier otra distribución basada en Raspbian no resultaría ser muy diferente.Preparando la SDHay que tener en cuenta que ésto borrará todo el contenido del dispositivo que seleccionemos.wget http://dietpi.com/downloads/DietPi_RPi-(Jessie).7z -O Dietpi.7z7z x Dietpi.7zdd if=DietPi_v94_RPi-(Jessie).img of=/dev/sd{X} #Donde {X} sera la sd donde cargaremos la imgsyncRealizando la instalación baseIntroducimos la SD en la Raspberry Pi y al encenderla se auto reiniciará un par de veces, dejándonos totalmente preparado el dispositivo con DietPi con la partición ya extendida.En el primer inicio de sesión que realizamos por SSH, el sistema se actualizará y volverá a reiniciar.En el próximo arranque nos preguntará si queremos utilizar un dispositivo USB para el sistema (a elección de cada uno queda). La próxima pantalla que veremos será la siguiente:En la primera opción se encuentra una lista de software ya preparado para instalar y funcionar, desgraciadamente en la ultima versión ya no se encuentra EmulationStation, parece ser que es debido a que en la instalación de EmulationStation se requiere de interacción por parte del usuario.Seleccionaremos “Start Install” y terminaremos con la instalación base de Dietpi.ActualizaciónActualizamos nuestra Raspberry Pi mediante el comando “rpi-update”OptimizaciónDivisión de la memoriadietpi-config1Display Options--&amp;gt;2 GPU/RAM Memory Split--&amp;gt;GamingCon la opción “Gaming” daremos a la GPU 256mb (la más alta que nos permite DietPi), sin embargo a diferencia que con “raspi–Config” en Raspbian, no nos permite seleccionar un valor manualmente, y el valor mas alto que nos permite es el de “Gaming”, con 256mb nos servirá para poder jugar a la mayoría de emuladores, pero poder hacer funcionar correctamente juegos de la PS1 seria necesario seleccionar 512mb, que para la Raspberry Pi 2b con 1G de memoria no tendrá problemas, para ello lo que podremos hacer es modificar manualmente el fichero /DietPi/config.txt y sobrescribir el valor manualmente a gpu_mem_1024=512 **y **reiniciar nuestro dispositivo.Para saber si todo salió bien desde el menú donde configurábamos el “Split” podremos ver en “current” 512mb.Frecuencia CPUConfiguraremos al 40% de uso de CPU donde la frecuencia aumente.dietpi-config3 Preformance Options--&amp;gt;CPU Throttle UPcambiamos su valor al 40%Instalación de EmulationStationwget https://github.com/RetroPie/RetroPie-Setup/archive/master.zip -O emu.zipunzip emu.zip -d emu_installcd emu_install/RetroPie-Setup-masterchmod +x retropie_setup.shsudo ./retropie_setup.shPodremos instalar desde los binarios o desde el código fuente, si no queremos malgastar nuestro tiempo, seleccionaremos la primera opción.Una vez la instalación haya finalizado, seleccionaremos la opción “3 Setup” y en el siguiente menú que aparecerá seleccionaremos “Auto-start EmulationStation” (si queremos que se auto inicie al arrancar la Raspberry) y “Install Xbox Contr. 360 driver” (para poder utilizar dichos mandos)Especificaciones del HardwareInsertando juegosDesde la ruta “/root/RetroPie/roms” de nuestra SD tendremos una carpeta para cada consola y dentro de ella los juegos de cada una, con copiar en su respectiva carpeta los juegos deseados nos bastará para que EmulationStation los reconozca y aparezcan.Podemos realizar una prueba rápida de su funcionamiento con SNES, para ello podemos usar este pequeño scriptcd /root/RetroPie/roms/sneswget http://download.freeroms.com/snes_roms/habu_meijin_no_omoshiro_shougi.7zapt-get install p7zip-full7z e habu_meijin_no_omoshiro_shougi.7zrm *.htm *.7zrebootEn el siguiente inicio ya aparecerá en el menú de EmulationStation la consola SNES y al entrar encontraremos el juego que acabamos de copiar." }, { "title": "¡¡ HELLO WORD !!", "url": "/posts/hello-word/", "categories": "Blog, やみのきし", "tags": "Blog", "date": "2015-08-19 22:19:07 +0200", "snippet": "" } ]
